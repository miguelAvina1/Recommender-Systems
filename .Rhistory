summary(t$freq)
boxplot(t$freq)
barplot(height = table(places$placeID)) # This plot is useful, it shows a nice represntation of the number of
# userID
# This was already a categorical (factor) variable, so we didn't do any modification
# We'll do the same analysis for this variable as we did for placeID becuase they are fair similar variables
barplot(height = table(places$userID))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'userID')
sprintf("Average places rated per User: %s", mean(t$freq))
summary(t$freq)  # We are going to advance a bit, but from here we can see that there's a restaurant with 36 vots and the restaurant
boxplot(t$freq)
View(places)
# Rating
# Rating was imported as numerical. If we check the dataframe using RStudio, we can manually observe that
# there is not more than 3 values: 0, 1, 2 . So turning it into categorical (factor) would be better
# However, lets assume we have a significantly larger dataset and visually inspecting the data woudln't be feasible
# Then, we would start by plotting the rating as histogram
hist(places$rating)
# From here, it is obvious that we have just three values
plot(density(places$rating))
# Even if we create the density plot, it is also obvious that is a three-modal density.
# So lets change it to a factor
places$rating <- as.factor(places$rating)
# To confirm, lets check the factors
factor(places$rating)
# To confirm, lets check the factors
summary(factor(places$rating))
prop.table(table(places$placeID)) # This is not useful
prop.table(table(places$rating)) # This is now useful
# Name
head(places$name)
# Name
places$name)
# Name
places$name
# Name
places$name[5]
# Name
places$name[1:5]
# Name
places$name[1:5,]
# Name
places$name[1:5,1]
# Name
places$name[1,1:5]
# Name
# There is not much thing we could do with this than observing a few obs
head(places$name)
View(places)
# Checking for missing data and storing the info.
# Creating the empty table to store the info:
missing_data <- matrix(data = 0, nrow = ncol(places), ncol = 3)
colnames(missing_data) <- c("Variable", "Occurrences", "Percentage")
missing_data[1:8, 1] <- colnames(places)
i <- 1
# Checking for missing data and storing the info.
# Creating the empty table to store the info:
missing_data <- matrix(data = 0, nrow = ncol(places), ncol = 3)
colnames(missing_data) <- c("Variable", "Occurrences", "Percentage")
missing_data[1:7, 1] <- colnames(places)
i <- 1
for (column in places) {
missing_data[i, 2] <- sum(is.na(column))
missing_data[i, 3] <- round(mean(is.na(column))*100, digits = 2)
i = i + 1
}
row_sub = apply(missing_data, 1, function(row) all(row !=0 )) # Checkig for zeros in rows
missing_data <- missing_data[row_sub,]                         # Subset to remove variables with complete data.
print("Missing data summary:")
print(missing_data)
# City
#
nlevels(places$city)  #
places$city
unique(places$city)
prop.table(table(places$city))
places$city <- factor(places$city, labels=c("Undefined","Cd. Victoria","Cd. Victoria","Cd. Victoria",
"Cuernavaca","Cuernavaca","Jiutepec", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"Soledad", "Cd. Victoria", "Cd. Victoria"))
# Now we have only 6 levels which are:
unique(places$city)
# Now we have only 6 levels which are:
levels(places$city)
levels(places$city) # we can observe the 17 cities by doing this
prop.table(table(places$city))
# Now we just do the same analisis as placeID/userID
barplot(height = table(places$city))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'rating')
summary(t$freq)  # The info of places and userID is quite similar.
boxplot(t$freq) # And here we observer what we mentioned before, there are not uncommon users: Nobody rated too much
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'rating')
summary(t$freq)  # Summary is useful just to know the city with less rankings (254) and with more (486)
# Now we just do the same analisis as placeID/userID
barplot(height = table(places$city))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'city')
summary(t$freq)  # Summary is useful just to know the city with less rankings (254) and with more (486)
boxplot(t$freq) # And here we observer what we mentioned before, there are not uncommon users: Nobody rated too much
head(places$latitude)
summary(places$latitude)
print(summary(places$latitude))
sprintf("Std dev: %s", round(sd(places$latitude, na.rm = TRUE), digits = 4))
boxplot(places$latitude, ylab = "Years", xlab = 'Age')
hist(places$latitude)
plot(density(places$latitude, na.rm = TRUE))
hist(places$latitude)
plot(density(places$latitude, na.rm = TRUE))
# Longitude
print(summary(places$longitude))
sprintf("Std dev: %s", round(sd(places$longitude, na.rm = TRUE), digits = 4))
boxplot(places$longitude, ylab = "Years", xlab = 'Age')
sprintf("Std dev: %s", round(sd(places$longitude, na.rm = TRUE), digits = 4))
boxplot(places$longitude, ylab = "Long", xlab = 'Longitude')
hist(places$longitude)  # In this plot we observe as we have divided in three different main locations regarding latitude
plot(density(places$longitude, na.rm = TRUE))  # Here we have 4 'peaks', so there may be locations in 4 different latitudes
hist(places$longitude)  # In this plot we observe as we have divided in three different main locations regarding latitude
plot(density(places$longitude, na.rm = TRUE))  # Here we have 4 'peaks', so there may be locations in 4 different longitude
plot(places$latitude, places$longitude)
levels(places$city)
plot(places$longitude, places$latitude)  # Now we can easily observe three main cumulus, but we have 5 different cities (and 1 undefined)
# realiza un an치lisis para determinar y justificar la decisi칩n
# que tomes sobre dichos datos perdidos.
# Ok so we have missing data in city (which came with the dataset since we imported it) and
# missing data in cuisine, that we added when merging cuisine data. NOTE that we could end without missing
# data in this variable if we haven't added the merge(places, cuisine, by="placeID", all=TRUE) 'all=TRUE'
# parameter to the merge operation, otherwise we would've ended with no missing data but fewer observations.
# So, for city we will
# 1. Use revgeo and ggmap to get the city name from lattitude and longitude
# 2. Using the data we have to create a k-means algorithm and get the city for the missing places
# 3. Compare both 1 and 2 outcomes
install.packages("revgeo")
install.packages("ggmap")
library(revgeo)
library(ggmap)
citations("ggmap")
citation("ggmap")
# Importing all the file
geoPlaces <- read.csv(file = "RCdata/geoplaces2.csv", header = TRUE, sep = ',')
rating    <- read.csv(file = "RCdata/rating_final.csv", header = TRUE, sep = ',')
cuisine   <- read.csv(file = "RCdata/chefmozcuisine.csv", header = TRUE, sep = ',')
# Keeping only with the previously mentioned variables
library(dplyr)
geoPlaces <- select(.data = geoPlaces, placeID, name, city, latitude, longitude)
rating    <- select(.data = rating, userID, placeID, rating)
cuisine   <- select(.data = cuisine, placeID, Rcuisine)
# Before continuing, we will display the first entries of each imported files.
# We recommended to perform this step to have a general idea of the the data we will
# be handling during the excercise
head(geoPlaces)
head(rating)
head(cuisine)
# Before doing this point, we want to know more regarding the data we imported.
# We observe that there are different number of observations in each one of the sets
dim(cuisine)[1]
dim(geoPlaces)[1]
dim(rating)[1]
# In rating we expect to have repeated both UserID and placeID, because each user
# could have rated more than one place, and more than one place could have had a
# score from many users.
# Just for clarity, we will extract the number of unique userID and placeID, which
# will tell us how many users and restaurants are in the dataset.
rating_UserIDs <- unique(rating$userID)
nlevels(rating_UserIDs)
# Know, for clarity also, we will extract the number of unique placeID
# We noticed that placeID is not a factor but a numerical value, this does not make sense
# since we can not have fractional placeID and they must be taken as categorical.
# Lets transform it to a factor
rating$placeID <- as.factor(rating$placeID)
nlevels(rating$placeID)
# We will also transform placeID from geoPlaces to factor.
geoPlaces$placeID <- as.factor(geoPlaces$placeID) # These are also 130 levels, being the 130 places
# For comprobation we will check if they are the SAME placeIDs in both geoPlaces and rating
setequal(unique(geoPlaces$placeID), unique(rating$placeID))
# However, we observed from the menu on the right that there are 129 levels of name,
# and we are expecting 130, one for each PlaceID. This tell us that there's a repeted name
# We can know it by doing:
n_occur <- data.frame(table((geoPlaces$name)))
n_occur[n_occur$Freq > 1,]
# We observed that we have a restaurant name repeated
geoPlaces[geoPlaces$name %in% n_occur$Var1[n_occur$Freq > 1],]
# FInally, we will analize the data in the cuisine dataframe. What we would expect here is
# to have the same 130 levels for placeID as in rating and geoPlaces.
# Rcuisine is a 59 level factor, which tell us that there are 59 kinds of restaurants in the dataset.
# However, we have 916 observations for placeID while we are only dealing with 130
# restaurants.
# Lets convert PlaceID also to a factor as we did for geoPlaces and rating
cuisine$placeID <- as.factor(cuisine$placeID)
nlevels(cuisine$placeID)
# Here we observer that there are 769 different PlaceID, so we have more information
# of restaurants here than in the other set. But, are there ALL the restaurants from
# rating here in cuisine?
commonPlaceIDs <- as.factor(intersect(cuisine$placeID, rating$placeID))
nlevels(commonPlaceIDs) # The intersection between placeID in cuisine and placeID in rating is 95 restaurants
n_occur <- data.frame(table(cuisine$placeID)) # Getting frequencies of each factor (placeID)
n_occur <- n_occur[order(-n_occur$Freq),]
head(n_occur[n_occur$Freq > 1,])  # here we can see the most repeated entries, one single placeID have 9 diff, cuisines!
# Lets look at some of these repeated entries
cuisine[cuisine$placeID %in% n_occur$Var1[n_occur$Freq > 1],][1:10,]
# We observe the pattern we have been describe
# Just for curiosity, we will observe the placeID with more assigned cuisines in this dataset
filter(cuisine, placeID == n_occur$Var1[1])  # Hilarious
# P. Ej si mergeamos geoPlaces and ratings, we are just adding the name to each entry, since we have name for ALL placeIDs
places <- merge(rating, geoPlaces, by="placeID") # And we end up with 1161 entries, everything good here!
# Lets prove what would happen if we merged it:
# Lets first get one placeID to focus on. We will choose one existing in both rating and cuisine dataset, so we will pick from commomPlaceIDs.
# From those common placeIDs, we will get one that have more than one cuisine assigned to it.
z <-  cuisine[cuisine$placeID %in% n_occur$Var1[n_occur$Freq > 1],]   # Getting all placeIDs we have with more than one cuisine
examplePlaceID <- intersect(commonPlaceIDs, z$placeID)[1]  # Extracting the first observation of reference
# Lets look at this placeID in ratings
filter(rating, placeID == examplePlaceID)  # So, we have a total of 10 votes, obviosly from different users
#Furthermore, from lets focus on a specific userID-PlaceID vote
examplePair <- filter(rating, placeID == examplePlaceID)[1,1:2]
examplePair
exampleUserID <- (examplePair[1])
badMerge <- merge(places, cuisine, by="placeID")
# Lets retrieve from this merge the placeID we are examination
z <- filter(badMerge, placeID == examplePlaceID) # Now, suddenly we have 20 votes (or ratings for this restaurant) instead of 10
z
# Now, lets get the userID-PlaceID in this bad merge
filter(z, userID ==  exampleUserID[1,1])
# we start by keeping just the placeIDs from cuisine we are interested (the 130 listed in geoPlaces):
cuisine <- filter(cuisine, placeID %in% commonPlaceIDs)  # We end up with 112 obs
# Demonstration in one placeID
currentPlaceID <- filter(cuisine, placeID == 135057)
new_level2 <- as.character(currentPlaceID$Rcuisine[1])
currentPlaceID <- currentPlaceID[-c(1),]
for (cuisineKind in currentPlaceID$Rcuisine) {
new_level2 <- paste(new_level2, as.character(cuisineKind), sep='_')
}
cuisine_merged0 <- cuisine  # We will use as a template (for factors and so) the cuisine dataframe
cuisine_merged0 <- cuisine_merged0[1,]  # And keep first variable to have the structure intact, we will remove this at the end
# ADD A DISCLAIMER THAT THERE IS NOT A LOT OF TRAINING IN R SO BAD PRACTICES AND INEFFICIENT CODE MAY BE PRESENT
cuisine_merged0 <- rbind(cuisine_merged0, c(135053, new_level2))
merged_Places <- list()
merged_Cuisines <- list()
for (place in commonPlaceIDs) { # We will iterate along each placeID we have
currentPlaceID <- filter(cuisine, placeID == place)    # and will examine one by one
new_level2 <- as.character(currentPlaceID$Rcuisine[1])
currentPlaceID <- currentPlaceID[-c(1),]
for (cuisineKind in currentPlaceID$Rcuisine) {
new_level2 <- paste(new_level2, as.character(cuisineKind), sep='_')
}
merged_Places <- c(merged_Places, place)
merged_Cuisines <- c(merged_Cuisines, new_level2)
}
cuisine <- data.frame('placeID' = unlist(merged_Places, use.names = FALSE), 'cuisine' = unlist(merged_Cuisines, use.names = FALSE) )
rm(merged_Places)
rm(merged_Cuisines)
rm(currentPlaceID)
# now lets just merge this data with the rest
places_drop <- merge(places, cuisine, by="placeID") # If we do this, we will lost all observations for which we don't have cuisine info
uniquePlaceID <- droplevels(as.factor(unique(places_drop$placeID)))  # demonstration of the previous sentence
nlevels(uniquePlaceID)
# INFO. We used droplevels because you can have levels with 0 occurencies, so to better reflect the number of existing factos, drop those
# We must not do this
places <- merge(places, cuisine, by="placeID", all=TRUE) # Here we dont lose info
levels(places[,8]) <- c(levels(places[,8]),"?")   # we are adding ? to tell that we dont have that info :(
places[is.na(places)] <- '?'
View(places)
head(places)
summary(places)
# placeID
# This variable was numeric and we already changed it to factor because it is actually a qualitative
nlevels(places$placeID)  # We have 130 levels, 130 places
# In previous homewook, we analyzed the proportion of observations per level, however, thi does not make sense
# since we can not combine them, and the analyzis we will do later does not benefit from merging levels
head(prop.table(table(places$placeID))) # This is not useful
barplot(height = table(places$placeID)) # This plot is useful, it shows a nice represntation of the number of
# install.packages('plyr')
# library('dplyr')
t <- count(places, 'placeID')
sprintf("Average votes per placeID: %s", mean(t$freq))
# Ok, we know that this is a categorical value, however, the number of votes per restaurant is numerical, lets analyze it a bit
summary(t$freq)  # We are going to advance a bit, but from here we can see that there's a restaurant with 36 vots and the restaurant
boxplot(t$freq)  # From here we know that there are some atipical values, this atipical values could be seen as
# userID
# This was already a categorical (factor) variable, so we didn't do any modification
# We'll do the same analysis for this variable as we did for placeID becuase they are fair similar variables
barplot(height = table(places$userID))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'userID')
sprintf("Average places rated per User: %s", mean(t$freq))
summary(t$freq)  # The info of places and userID is quite similar.
boxplot(t$freq) # And here we observer what we mentioned before, there are not uncommon users: Nobody rated too much
# Rating
# Rating was imported as numerical. If we check the dataframe using RStudio, we can manually observe that
# there is not more than 3 values: 0, 1, 2 . So turning it into categorical (factor) would be better
# However, lets assume we have a significantly larger dataset and visually inspecting the data woudln't be feasible
# Then, we would start by plotting the rating as histogram
hist(places$rating)
# From here, it is obvious that we have just three values
plot(density(places$rating))
# Even if we create the density plot, it is also obvious that is a three-modal density.
# So lets change it to a factor
places$rating <- as.factor(places$rating)
# To confirm, lets check the factors
summary(factor(places$rating))
prop.table(table(places$rating)) # This is now useful
# Name
# There is not much thing we could do with this than observing a few obs
head(places$name) # Each place name is correlated to placeID so this variable just add a better identifier to the numerical placeID
# City
#
nlevels(places$city)  # 17 cities
levels(places$city) # we can observe the 17 cities by doing this
places$city <- factor(places$city, labels=c("Undefined","Cd. Victoria","Cd. Victoria","Cd. Victoria",
"Cuernavaca","Cuernavaca","Jiutepec", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"Soledad", "Cd. Victoria", "Cd. Victoria"))
# Now we have only 6 levels which are:
levels(places$city)
prop.table(table(places$city))
# Now we just do the same analisis as placeID/userID
barplot(height = table(places$city))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'city')
summary(t$freq)  # Summary is useful just to know the city with less rankings (834) and with more (17)
boxplot(t$freq) # Also, the boxplot doesn't show anything
print(summary(places$latitude))
sprintf("Std dev: %s", round(sd(places$latitude, na.rm = TRUE), digits = 4))
boxplot(places$latitude, ylab = "Lat", xlab = 'Latitude')
hist(places$latitude)  # In this plot we observe as we have divided in three different main locations regarding latitude
plot(density(places$latitude, na.rm = TRUE))  # Here we have 4 'peaks', so there may be locations in 4 different latitudes
# Longitude
print(summary(places$longitude))
sprintf("Std dev: %s", round(sd(places$longitude, na.rm = TRUE), digits = 4))
boxplot(places$longitude, ylab = "Long", xlab = 'Longitude')
hist(places$longitude)  # In this plot we observe as we have divided in four different main locations regarding longitude
plot(density(places$longitude, na.rm = TRUE))  # Here we have 4 'peaks', so there may be locations in 4 different longitude
plot(places$longitude, places$latitude)  # Now we can easily observe three main cumulus, but we have 5 different cities (and 1 undefined)
# realiza un an치lisis para determinar y justificar la decisi칩n
# que tomes sobre dichos datos perdidos.
# Ok so we have missing data in city (which came with the dataset since we imported it) and
# missing data in cuisine, that we added when merging cuisine data. NOTE that we could end without missing
# data in this variable if we haven't added the merge(places, cuisine, by="placeID", all=TRUE) 'all=TRUE'
# parameter to the merge operation, otherwise we would've ended with no missing data but fewer observations.
# So, for city we will
# 1. Use revgeo and ggmap to get the city name from lattitude and longitude
# 2. Using the data we have to create a k-means algorithm and get the city for the missing places
# 3. Compare both 1 and 2 outcomes
install.packages("revgeo")
places <- droplevels(places)
places <- droplevels(places)
places$cuisine <- droplevels(as.factor(unique(places$cuisine)))
places$cuisine <- droplevels(unique(places$cuisine))
places$cuisine <- droplevels(as.factor(unique(places$cuisine)))
levels(places[,8]) <- c(levels(places[,8]),"?")   # we are adding ? to tell that we dont have that info :(
places[is.na(places)] <- '?'
head(places)
summary(places)
# placeID
# This variable was numeric and we already changed it to factor because it is actually a qualitative
nlevels(places$placeID)  # We have 130 levels, 130 places
# In previous homewook, we analyzed the proportion of observations per level, however, thi does not make sense
# since we can not combine them, and the analyzis we will do later does not benefit from merging levels
head(prop.table(table(places$placeID))) # This is not useful
barplot(height = table(places$placeID)) # This plot is useful, it shows a nice represntation of the number of
# install.packages('plyr')
# library('dplyr')
t <- count(places, 'placeID')
sprintf("Average votes per placeID: %s", mean(t$freq))
# Ok, we know that this is a categorical value, however, the number of votes per restaurant is numerical, lets analyze it a bit
summary(t$freq)  # We are going to advance a bit, but from here we can see that there's a restaurant with 36 vots and the restaurant
boxplot(t$freq)  # From here we know that there are some atipical values, this atipical values could be seen as
# userID
# This was already a categorical (factor) variable, so we didn't do any modification
# We'll do the same analysis for this variable as we did for placeID becuase they are fair similar variables
barplot(height = table(places$userID))
# GRaphically, we are observing the number of places each user has rated. It doesn't show too uncommon users,
# altough there are some large bars, they doesn't seem as different as those from places
t <- count(places, 'userID')
sprintf("Average places rated per User: %s", mean(t$freq))
summary(t$freq)  # The info of places and userID is quite similar.
boxplot(t$freq) # And here we observer what we mentioned before, there are not uncommon users: Nobody rated too much
# Rating
# Rating was imported as numerical. If we check the dataframe using RStudio, we can manually observe that
# there is not more than 3 values: 0, 1, 2 . So turning it into categorical (factor) would be better
# However, lets assume we have a significantly larger dataset and visually inspecting the data woudln't be feasible
# Then, we would start by plotting the rating as histogram
hist(places$rating)
# From here, it is obvious that we have just three values
plot(density(places$rating))
# Even if we create the density plot, it is also obvious that is a three-modal density.
# So lets change it to a factor
places$rating <- as.factor(places$rating)
# To confirm, lets check the factors
summary(factor(places$rating))
prop.table(table(places$rating)) # This is now useful
# Name
# There is not much thing we could do with this than observing a few obs
head(places$name) # Each place name is correlated to placeID so this variable just add a better identifier to the numerical placeID
# City
#
nlevels(places$city)  # 17 cities
levels(places$city) # we can observe the 17 cities by doing this
places$city <- factor(places$city, labels=c("Undefined","Cd. Victoria","Cd. Victoria","Cd. Victoria",
"Cuernavaca","Cuernavaca","Jiutepec", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"San Luis Potosi", "San Luis Potosi", "San Luis Potosi",
"Soledad", "Cd. Victoria", "Cd. Victoria"))
# Now we have only 6 levels which are:
levels(places$city)
prop.table(table(places$city))
# FInally, the last variable
# Cuisine
# This was already a categorical (factor) variable, so we didn't do any modification
barplot(height = table(places$cuisine))
# GRaphically, we cant observe much...
t <- count(places, 'cuisine')
sprintf("Average places rated per User: %s", mean(t$freq))
sprintf("Average places per cuisine: %s", mean(t$freq))
summary(t$freq)  # The info of places and userID is quite similar.
boxplot(t$freq) # And here we observer what we mentioned before, there are not uncommon users: Nobody rated too much
outvals <- boxplot(t$freq) # So we have two outliers, one we know if from '?' The other one should be the most popular
View(outvals)
# cuisine of all restaurants
str(outvals)
# cuisine of all restaurants
outvals
outvals <- boxplot(t$freq)$out # So we have two outliers, one we know if from '?' The other one should be the most popular
# cuisine of all restaurants
outvals
which(t$freq %in$% outvals)
which(t$freq %in% outvals)
t$freq[sales %in% outvals]
t$freq[t$freq %in% outvals]
t$freq[25]
View(t)
t[25]
t[25,2]
t[25,]
which(t$freq %in% outvals)
t[which(t$freq %in% outvals),]
# cuisine of all restaurants which is:
t[which(t$freq %in% outvals),]
undef_cities <- filter(places, cuisine == '?')
View(undef_cities)
undef_cities <- filter(places, city == 'undefined')
View(places)
undef_cities <- filter(places, city == 'Undefined')
View(undef_cities)
revgeo(undef_cities$longitude[1], undef_cities$latitude[1])
def_cities <- revgeo(undef_cities$longitude[1], undef_cities$latitude[1])
View(def_cities)
unlist(strsplit(def_cities, ","))
unlist(strsplit(def_cities[1], ","))
unlist(strsplit(as.character(def_cities[1]), ","))
unlist(strsplit(as.character(def_cities[1]), ", "))
unlist(strsplit(as.character(def_cities[1]), ", "))[2]
def_cities <- revgeo(undef_cities$longitude, undef_cities$latitude)
def_cities <- unlist(strsplit(as.character(def_cities), ", "))[2]
def_cities <- revgeo(undef_cities$longitude, undef_cities$latitude)
cities <- unlist(strsplit(as.character(def_cities), ", "))[2]
undef_cities <- filter(places, city == 'Undefined')
undef_cities$city <- revgeo(undef_cities$longitude, undef_cities$latitude)
View(undef_cities)
undef_cities$city <- unlist(strsplit(as.character(city), ", "))[2]
View(undef_cities)
for (cit in undef_cities$city) {
undef_cities$city <- unlist(strsplit(as.character(cit), ", "))[2]
}
undef_cities <- filter(places, city == 'Undefined')
undef_cities$city <- revgeo(undef_cities$longitude, undef_cities$latitude)
undef_cities_backup <- undef_cities
View(undef_cities_backup)
unlist(strsplit(as.character(cit), ", "))[2]
for (cit in undef_cities$city) {
unlist(strsplit(as.character(cit), ", "))[2]
}
for (cit in undef_cities$city) {
unlist(strsplit(as.character(cit), ", "))[2]
}
print(unlist(strsplit(as.character(cit), ", "))[2])
for (cit in undef_cities$city) {
print(unlist(strsplit(as.character(cit), ", "))[2])
}
for (cit in undef_cities$city) {
undef_cities$city[counter] <- unlist(strsplit(as.character(cit), ", "))[2]
counter <- counter + 1
}
counter <- 0
for (cit in undef_cities$city) {
undef_cities$city[counter] <- unlist(strsplit(as.character(cit), ", "))[2]
counter <- counter + 1
}
View(undef_cities)
counter <- 1
for (cit in undef_cities$city) {
undef_cities$city[counter] <- unlist(strsplit(as.character(cit), ", "))[2]
counter <- counter + 1
}
undef_cities <- undef_cities_backup
counter <- 1
for (cit in undef_cities$city) {
undef_cities$city[counter] <- unlist(strsplit(as.character(cit), ", "))[2]
counter <- counter + 1
}
View(undef_cities)
places <- merge(places, undef_cities, by='placeID')
View(places)
